# Shopify Backup - Work Items

Generated by Face (A(i)-Team Decomposer)
Second Pass - With Sosa refinements and human answers applied

---

## Summary

| Item | Title | Dependencies | Parallel Group | Stage |
|------|-------|--------------|----------------|-------|
| 001 | Project scaffolding | - | setup | ready |
| 002 | Shopify API client with retry wrapper | 001 | api | ready |
| 003 | Products backup with metafields | 002 | backup-modules | briefings |
| 004 | Customers backup with metafields | 002 | backup-modules | briefings |
| 005 | Orders backup (full history) with metafields | 002 | backup-modules | briefings |
| 006 | Content backup (pages, collections, blogs) | 002 | backup-modules | briefings |
| 007 | Product images download with retry | 002 | images | briefings |
| 008 | Retention cleanup | 001 | cleanup | ready |
| 009 | Main orchestration with status.json | 003, 004, 005, 006, 007, 008 | orchestration | briefings |
| 010 | Dockerfile and deployment config | 009 | deployment | briefings |

**Wave 0 (no dependencies, ready to start):** 001, 002, 008
**Wave 1:** 003, 004, 005, 006, 007
**Wave 2:** 009
**Wave 3:** 010

---

## Item 001: Project Scaffolding

**Dependencies:** None
**Parallel Group:** setup
**Stage:** ready

### Files to Create

1. `src/__tests__/config.test.ts` - Test configuration loading
2. `src/config.ts` - Configuration module
3. `src/types.ts` - Shared TypeScript types
4. `package.json` - Project manifest
5. `tsconfig.json` - TypeScript configuration
6. `vitest.config.ts` - Test configuration
7. `.env.example` - Environment variable template

### Objective

Set up the Node.js + TypeScript project structure with configuration loading from environment variables.

### Acceptance Criteria

- [ ] `package.json` includes dependencies: `@shopify/shopify-api`, `typescript`, `vitest`, `tsx`
- [ ] `tsconfig.json` targets ES2022, enables strict mode, outputs to `dist/`
- [ ] `vitest.config.ts` configured for TypeScript with coverage
- [ ] `src/config.ts` exports a `getConfig()` function that reads:
  - `SHOPIFY_STORE` (required)
  - `SHOPIFY_ACCESS_TOKEN` (required)
  - `BACKUP_DIR` (default: `/backups/shopify`)
  - `RETENTION_DAYS` (default: 30)
- [ ] `getConfig()` throws descriptive error if required env vars missing
- [ ] `src/types.ts` exports `BackupConfig` interface
- [ ] `.env.example` documents all environment variables with example values
- [ ] `pnpm test` runs successfully with at least one passing test
- [ ] `pnpm run lint` passes (add eslint with typescript-eslint)

### Technical Notes

- Use ESM modules (`"type": "module"` in package.json)
- Config should be validated at startup, fail fast on missing required values
- Types file will be extended by other modules as needed

---

## Item 002: Shopify API Client with Retry Wrapper

**Dependencies:** 001
**Parallel Group:** api
**Stage:** ready (after 001 completes)

### Files to Create

1. `src/__tests__/shopify.test.ts` - Test API client and retry logic
2. `src/shopify.ts` - Shopify API client module

### Objective

Create a configured Shopify Admin API client pinned to version 2025-01 with a generic retry wrapper for rate limit handling.

### Acceptance Criteria

- [ ] Creates Shopify Admin API client using `@shopify/shopify-api`
- [ ] **API version pinned to "2025-01"** (not latest, explicit pin)
- [ ] Client authenticates using access token from config
- [ ] Exports `createShopifyClient(config: BackupConfig)` function
- [ ] **Exports generic `withRetry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>` wrapper**
- [ ] Retry wrapper implements exponential backoff:
  - Default max retries: 3
  - Base delay: 1000ms
  - Backoff multiplier: 2 (1s, 2s, 4s)
  - Jitter: +/- 10%
- [ ] Retry wrapper handles HTTP 429 (rate limit) responses
- [ ] Retry wrapper handles network errors (ECONNRESET, ETIMEDOUT)
- [ ] Retry wrapper logs each retry attempt with attempt number and delay
- [ ] After max retries exhausted, throws original error with retry count in message
- [ ] Unit tests mock Shopify API and verify:
  - Successful requests pass through
  - 429 responses trigger retry with backoff
  - Max retries eventually throws
  - Non-retryable errors (4xx except 429) throw immediately

### Technical Notes

```typescript
interface RetryOptions {
  maxRetries?: number;      // default: 3
  baseDelay?: number;       // default: 1000ms
  maxDelay?: number;        // default: 30000ms
  retryableStatuses?: number[]; // default: [429, 500, 502, 503, 504]
}
```

The retry wrapper is generic and will be used by:
- All backup modules for API calls
- Image downloader for HTTP requests

---

## Item 003: Products Backup with Metafields

**Dependencies:** 002
**Parallel Group:** backup-modules
**Stage:** briefings

### Files to Create

1. `src/__tests__/backup/products.test.ts` - Test products backup
2. `src/backup/products.ts` - Products backup module

### Objective

Backup all products including variants, with metafields for both products and variants.

### Acceptance Criteria

- [ ] Exports `backupProducts(client, outputDir): Promise<BackupResult>` function
- [ ] Fetches ALL products using pagination (cursor-based)
- [ ] For each product, includes all standard fields (title, description, handle, vendor, etc.)
- [ ] For each product, includes all variants with full variant data
- [ ] **For each product, fetches and includes product metafields in a `metafields` array**
- [ ] **For each variant, fetches and includes variant metafields in a `metafields` array**
- [ ] Uses `withRetry` wrapper for all API calls
- [ ] Writes `products.json` to outputDir with array of products
- [ ] Returns `BackupResult` with:
  - `success: boolean`
  - `count: number` (products backed up)
  - `error?: string` (if failed)
- [ ] Handles empty store (0 products) gracefully
- [ ] Unit tests verify:
  - Pagination works correctly
  - Metafields are included for products
  - Metafields are included for variants
  - Output JSON structure is correct
  - Errors return failed BackupResult (don't throw)

### Technical Notes

Product metafields endpoint: `GET /admin/api/2025-01/products/{id}/metafields.json`
Variant metafields endpoint: `GET /admin/api/2025-01/variants/{id}/metafields.json`

Output structure:
```json
{
  "id": 12345,
  "title": "Product Name",
  "metafields": [
    { "namespace": "custom", "key": "care_instructions", "value": "..." }
  ],
  "variants": [
    {
      "id": 67890,
      "title": "Small",
      "metafields": [
        { "namespace": "inventory", "key": "warehouse_location", "value": "A1" }
      ]
    }
  ]
}
```

---

## Item 004: Customers Backup with Metafields

**Dependencies:** 002
**Parallel Group:** backup-modules
**Stage:** briefings

### Files to Create

1. `src/__tests__/backup/customers.test.ts` - Test customers backup
2. `src/backup/customers.ts` - Customers backup module

### Objective

Backup all customers with their metafields.

### Acceptance Criteria

- [ ] Exports `backupCustomers(client, outputDir): Promise<BackupResult>` function
- [ ] Fetches ALL customers using pagination (cursor-based)
- [ ] For each customer, includes all standard fields
- [ ] **For each customer, fetches and includes customer metafields in a `metafields` array**
- [ ] Uses `withRetry` wrapper for all API calls
- [ ] Writes `customers.json` to outputDir with array of customers
- [ ] Returns `BackupResult` with success, count, error
- [ ] Handles empty customer list gracefully
- [ ] Unit tests verify:
  - Pagination works correctly
  - Metafields are included for each customer
  - Output JSON structure is correct
  - Errors return failed BackupResult

### Technical Notes

Customer metafields endpoint: `GET /admin/api/2025-01/customers/{id}/metafields.json`

Output structure:
```json
{
  "id": 11111,
  "email": "customer@example.com",
  "first_name": "Jane",
  "metafields": [
    { "namespace": "loyalty", "key": "points", "value": "500" }
  ]
}
```

---

## Item 005: Orders Backup (Full History) with Metafields

**Dependencies:** 002
**Parallel Group:** backup-modules
**Stage:** briefings

### Files to Create

1. `src/__tests__/backup/orders.test.ts` - Test orders backup
2. `src/backup/orders.ts` - Orders backup module

### Objective

Backup ALL orders (complete history, no date filtering) with their metafields.

### Acceptance Criteria

- [ ] Exports `backupOrders(client, outputDir): Promise<BackupResult>` function
- [ ] **Fetches ALL orders - complete history, NO date filtering**
- [ ] Uses `status=any` to include all order statuses (open, closed, cancelled)
- [ ] Uses pagination (cursor-based) to handle large order volumes
- [ ] For each order, includes all standard fields (line items, shipping, billing, etc.)
- [ ] **For each order, fetches and includes order metafields in a `metafields` array**
- [ ] Uses `withRetry` wrapper for all API calls
- [ ] Writes `orders.json` to outputDir with array of orders
- [ ] Returns `BackupResult` with success, count, error
- [ ] Handles stores with no orders gracefully
- [ ] Unit tests verify:
  - ALL orders are fetched (no date filter)
  - All statuses included
  - Metafields are included for each order
  - Output JSON structure is correct
  - Errors return failed BackupResult

### Technical Notes

Orders endpoint: `GET /admin/api/2025-01/orders.json?status=any`

The `status=any` parameter is critical - default only returns open orders.

For stores with very large order histories (10k+), this may take a while. The retry wrapper handles rate limiting.

---

## Item 006: Content Backup (Pages, Collections, Blogs) with Metafields

**Dependencies:** 002
**Parallel Group:** backup-modules
**Stage:** briefings

### Files to Create

1. `src/__tests__/backup/content.test.ts` - Test content backup
2. `src/backup/content.ts` - Content backup module

### Objective

Backup pages, collections (smart and custom), blogs with articles, shop-level metafields, and collection metafields.

### Acceptance Criteria

- [ ] Exports `backupContent(client, outputDir): Promise<ContentBackupResult>` function
- [ ] **Pages:** Fetches all pages, writes `pages.json`
- [ ] **Collections:** Fetches all smart and custom collections
- [ ] **For each collection, fetches and includes collection metafields in a `metafields` array**
- [ ] Writes `collections.json` with array of collections (both types merged)
- [ ] **Blogs:** Fetches all blogs with their articles, writes `blogs.json`
- [ ] **Shop metafields:** Fetches shop-level metafields only
- [ ] **Writes `metafields.json` containing ONLY shop-level metafields** (not resource metafields)
- [ ] Uses `withRetry` wrapper for all API calls
- [ ] Returns `ContentBackupResult` with per-resource results:
  - `pages: BackupResult`
  - `collections: BackupResult`
  - `blogs: BackupResult`
  - `shopMetafields: BackupResult`
- [ ] Unit tests verify:
  - All content types are fetched
  - Collection metafields are included in collections.json
  - metafields.json contains only shop-level metafields
  - Output structure is correct for each file

### Technical Notes

**Important clarification on metafields.json:**
- `metafields.json` = shop-level metafields ONLY (store settings, global config)
- Resource metafields (products, customers, orders, collections) go in their respective JSON files

Shop metafields endpoint: `GET /admin/api/2025-01/metafields.json` (no resource prefix)
Collection metafields: `GET /admin/api/2025-01/collections/{id}/metafields.json`

---

## Item 007: Product Images Download with Retry

**Dependencies:** 002
**Parallel Group:** images
**Stage:** briefings

### Files to Create

1. `src/__tests__/images.test.ts` - Test image download logic
2. `src/images.ts` - Image download module

### Objective

Download all product images to disk with retry logic for failed downloads.

### Acceptance Criteria

- [ ] Exports `downloadProductImages(products, outputDir): Promise<ImageDownloadResult>` function
- [ ] Creates `images/{product_id}/` subdirectory for each product with images
- [ ] Downloads each image, naming by position: `1.jpg`, `2.png`, etc.
- [ ] Preserves original file extension from URL
- [ ] **Implements retry logic: 3 attempts with exponential backoff**
  - Uses the generic `withRetry` wrapper from shopify.ts
  - Configured for image downloads (may need different retry options)
- [ ] **After 3 failed attempts, logs warning and continues** (does not abort)
- [ ] **Tracks all failed image URLs for status.json**
- [ ] Returns `ImageDownloadResult`:
  - `success: boolean` (true if at least some images downloaded)
  - `downloaded: number` (count of successfully downloaded images)
  - `failed: number` (count of failed images after all retries)
  - `failedUrls: string[]` (list of URLs that failed for status.json)
- [ ] Handles products with no images gracefully
- [ ] Skips download if file already exists (idempotent)
- [ ] Unit tests verify:
  - Images are downloaded to correct paths
  - Retry logic triggers on failure
  - After 3 failures, continues with next image
  - Failed URLs are tracked correctly
  - File naming is correct (1.jpg, 2.png, etc.)

### Technical Notes

Image URLs from Shopify look like:
`https://cdn.shopify.com/s/files/1/0123/4567/8901/products/image.jpg?v=1234567890`

Extract extension from URL path (before query string).

Output structure:
```
images/
  12345/
    1.jpg
    2.jpg
  67890/
    1.png
```

The `failedUrls` array is passed to the orchestrator for inclusion in status.json.

---

## Item 008: Retention Cleanup

**Dependencies:** 001
**Parallel Group:** cleanup
**Stage:** ready

### Files to Create

1. `src/__tests__/cleanup.test.ts` - Test retention cleanup
2. `src/cleanup.ts` - Retention cleanup module

### Objective

Delete backup directories older than the configured retention period.

### Acceptance Criteria

- [ ] Exports `cleanupOldBackups(backupDir, retentionDays): Promise<CleanupResult>` function
- [ ] Scans `backupDir` for date-stamped directories (format: `YYYY-MM-DD`)
- [ ] Calculates age of each directory based on directory name (not filesystem mtime)
- [ ] Deletes directories older than `retentionDays`
- [ ] Returns `CleanupResult`:
  - `deleted: string[]` (list of deleted directory names)
  - `kept: string[]` (list of kept directory names)
  - `errors: string[]` (any deletion errors)
- [ ] Ignores non-date directories (doesn't delete random folders)
- [ ] Handles empty backup directory gracefully
- [ ] Handles permission errors gracefully (logs, continues with others)
- [ ] Unit tests verify:
  - Old directories are deleted
  - New directories are kept
  - Non-date directories are ignored
  - Edge cases (retention=0, retention=365)

### Technical Notes

Directory naming: `YYYY-MM-DD` (e.g., `2026-01-25`)

Use regex to validate: `/^\d{4}-\d{2}-\d{2}$/`

Parse date from directory name, compare to current date minus retentionDays.

---

## Item 009: Main Orchestration with status.json

**Dependencies:** 003, 004, 005, 006, 007, 008
**Parallel Group:** orchestration
**Stage:** briefings

### Files to Create

1. `src/__tests__/backup.test.ts` - Test main orchestration
2. `src/backup.ts` - Main backup orchestration

### Objective

Orchestrate all backup modules, handle partial failures gracefully, and write comprehensive status.json.

### Acceptance Criteria

- [ ] Exports `runBackup(config: BackupConfig): Promise<BackupStatus>` function
- [ ] Creates date-stamped output directory: `{BACKUP_DIR}/YYYY-MM-DD/`
- [ ] Runs all backup modules in sequence:
  1. Products backup
  2. Customers backup
  3. Orders backup
  4. Content backup (pages, collections, blogs, shop metafields)
  5. Product images download
  6. Retention cleanup
- [ ] **On module failure: logs error and CONTINUES with remaining modules**
- [ ] **Does NOT abort on partial failure** - completes all possible work
- [ ] **Writes `status.json` at end with comprehensive status:**
  ```json
  {
    "started_at": "2026-01-25T02:00:00.000Z",
    "completed_at": "2026-01-25T02:04:32.000Z",
    "backup_dir": "/backups/shopify/2026-01-25",
    "modules": {
      "products": "success",
      "customers": "success",
      "orders": "failed",
      "pages": "success",
      "collections": "success",
      "blogs": "success",
      "shop_metafields": "success",
      "images": "partial"
    },
    "counts": {
      "products": 150,
      "customers": 500,
      "orders": 0,
      "pages": 5,
      "collections": 10,
      "blogs": 2
    },
    "images": {
      "downloaded": 425,
      "failed": 3
    },
    "failed_images": [
      "https://cdn.shopify.com/...",
      "https://cdn.shopify.com/...",
      "https://cdn.shopify.com/..."
    ],
    "cleanup": {
      "deleted": ["2025-12-25", "2025-12-26"],
      "kept": ["2026-01-24", "2026-01-25"]
    },
    "errors": [
      "Orders backup failed: API error 500"
    ]
  }
  ```
- [ ] Returns `BackupStatus` object (same structure as status.json)
- [ ] Exits with code 0 if all modules succeeded
- [ ] Exits with code 1 if any module failed (but still writes status.json first)
- [ ] Unit tests verify:
  - All modules are called in sequence
  - Partial failures don't abort other modules
  - status.json is written with correct structure
  - Failed images are included in status.json
  - Exit codes are correct

### Technical Notes

Module status values:
- `"success"` - completed without errors
- `"failed"` - could not complete
- `"partial"` - completed with some failures (e.g., some images failed)

The orchestrator coordinates modules but doesn't contain backup logic itself.

---

## Item 010: Dockerfile and Deployment Config

**Dependencies:** 009
**Parallel Group:** deployment
**Stage:** briefings

### Files to Create

1. `Dockerfile` - Container image definition
2. `.dockerignore` - Files to exclude from build
3. `.env.example` - Update with all variables (if not complete)

### Objective

Create production-ready Docker configuration for Dokploy deployment.

### Acceptance Criteria

- [ ] Multi-stage Dockerfile:
  - Build stage: Install deps, compile TypeScript
  - Production stage: Node alpine, only runtime deps
- [ ] Final image size < 200MB
- [ ] Runs as non-root user
- [ ] Entry point: `node dist/index.js`
- [ ] `.dockerignore` excludes: `node_modules`, `dist`, `.git`, `*.md`, tests
- [ ] Health check not needed (it's a cron job, not a service)
- [ ] `.env.example` documents all environment variables:
  - `SHOPIFY_STORE`
  - `SHOPIFY_ACCESS_TOKEN`
  - `BACKUP_DIR`
  - `RETENTION_DAYS`
- [ ] Dockerfile builds successfully: `docker build -t shopify-backup .`
- [ ] Container runs successfully with env vars mounted
- [ ] Dokploy cron schedule documented: `0 2 * * *` (daily at 2am)

### Technical Notes

Dokploy mounts the backup volume at `/backups`. The script writes to `/backups/shopify/`.

Example Dockerfile structure:
```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && pnpm install --frozen-lockfile
COPY . .
RUN pnpm build

FROM node:20-alpine
WORKDIR /app
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
USER nodejs
CMD ["node", "dist/index.js"]
```

---

## Shared Types Reference

These types should be defined in `src/types.ts` and extended as modules are built:

```typescript
export interface BackupConfig {
  shopifyStore: string;
  shopifyAccessToken: string;
  backupDir: string;
  retentionDays: number;
}

export interface BackupResult {
  success: boolean;
  count: number;
  error?: string;
}

export interface ImageDownloadResult {
  success: boolean;
  downloaded: number;
  failed: number;
  failedUrls: string[];
}

export interface CleanupResult {
  deleted: string[];
  kept: string[];
  errors: string[];
}

export interface BackupStatus {
  started_at: string;
  completed_at: string;
  backup_dir: string;
  modules: Record<string, 'success' | 'failed' | 'partial'>;
  counts: Record<string, number>;
  images: {
    downloaded: number;
    failed: number;
  };
  failed_images: string[];
  cleanup: CleanupResult;
  errors: string[];
}

export interface RetryOptions {
  maxRetries?: number;
  baseDelay?: number;
  maxDelay?: number;
  retryableStatuses?: number[];
}
```

---

## Dependency Graph

```
001 (scaffolding)
 |
 +---> 002 (shopify client) --+--> 003 (products)
 |                            +--> 004 (customers)
 |                            +--> 005 (orders)
 |                            +--> 006 (content)
 |                            +--> 007 (images)
 |
 +---> 008 (cleanup)
                    \
                     +--> 009 (orchestration) --> 010 (dockerfile)
                    /
       003, 004, 005, 006, 007
```

---

## Execution Order

**Wave 0** (parallel, no dependencies):
- 001: Project scaffolding
- 008: Retention cleanup (only depends on fs, not Shopify)

**Wave 1** (after 001):
- 002: Shopify API client

**Wave 2** (after 002, parallel):
- 003: Products backup
- 004: Customers backup
- 005: Orders backup
- 006: Content backup
- 007: Images download

**Wave 3** (after all backup modules):
- 009: Main orchestration

**Wave 4** (after 009):
- 010: Dockerfile
